Introduction to Programming - Basics
	Source Code: User written code in a human readable language.
	
	Byte Code: A fixed set of instructions that represents all operations like arithmetic, comparison, memory related operations etc.
		Bytecode is also referred to as P-code or Portable code. This code cannot be read by human.
		A compiler converts Source Code to Bytecode.
		Bytecode will be generated only when there is no compiler error. Ex. Say, you make a mistake in syntax, then the compilation will not be successful. Hence, there won't be bytecode generated.
		Extension of bytecode is *.pyc
		
	Machine Code: Comprises of 0's and 1's that can be understood by machines.
		An interpreter converts bytecode in to machine code.
		Machine code will not be generated if there is a runtime error. Ex. Say you have asked to print a variable that is not defined. It will lead to runtime error.
	
	Check out the Snippet for Generating Byte Code

1. Python is Free & Open Source (Source code can be obtained).
2. Python platform independant (Program can run in Win, Mac, Linux etc)
	Example: Win system compiled *.exe file cannot run in Mac or Linux especially for C
	Thus, we say C program is platform dependant.
	Python is platform independant, i.e. Bytecode generated on any OS can run in any OS.
3. Python is Portable: Source code running in one OS can be transferred to another OS without any modification.
	C is also portable.
4. Python is extensible: Code written in other prgramming language can be used in Python
5. Python is embedded: Code written in Python can be used in other Programming Languages.

# Input & Output Functions
Understand: Input, Eval, Print # Pay Attention to format

Cmponent | Datatypes | Operators

I Components of Python
	1. Literal - Any constant value
		a  int literal = 10
		b. float literal = 10.2
		c. Boolean = True 
		d. Decimal = 123
		e. Hexadecimal = 0xfc98
		f. Octal = 0o7654
		g. String = 'Dolly'
		h. Complex = 10 + 3j
##############

import os, datetime

# Working directory
directory = r"C:\Testing_Only"
os.chdir( directory )

# extensions for files that we want rename
extensions = (['.txt'])

# Get a list of files in the directory
filelist = os.listdir( directory )

# New file dictionary
newfilesDictionary = {}

# count the number of files that are renamed
count = 0

for file in filelist:
	# split the file into filename and extension
	filename, extension = os.path.splitext(file)
	# if the extension is a valid extension
	if ( extension in extensions ):
		# Get the create time of the file
		create_time = os.path.getmtime( file )
		# get the readable timestamp format 
		format_time = datetime.datetime.fromtimestamp( create_time )
		# convert time into string
		format_time_string = format_time.strftime("%Y-%m-%d %H.%M.%S") # e.g. 2015-01-01 09.00.00.jpg
		# Contruct the new name of the file
		newfile = format_time_string + extension; 

		# If there is other files created at the same timestamp
		if ( newfile in newfilesDictionary.keys() ):
			index = newfilesDictionary[newfile] + 1;
			newfilesDictionary[newfile] = index; 
			newfile = format_time_string + '-' + str(index) + extension; # e.g. 2015-01-01 09.00.00-1.jpg
		else:
			newfilesDictionary[newfile] = 0; 

		# rename the file
		os.rename( file, newfile );
		# count the number of files that are renamed
		count = count + 1
		# printing log
		print( file.rjust(35) + '    =>    ' + newfile.ljust(35) )


print( 'All done. ' + str(count) + ' files are renamed. ')
##############################################################
import pandas as pd
import os
import glob

# Step 1: get a list of all csv files in target directory
my_dir = r"C:\Testing_Only"
filelist = []
filesList = []
os.chdir( my_dir )

# Step 2: Build up list of files:
for files in glob.glob("*.txt"):
    fileName, fileExtension = os.path.splitext(files)
    filelist.append(fileName) #filename without extension
    filesList.append(files) #filename with extension
    filesList.sort()
#print(filesList)

# Step 3: Build the DataFrame
df = pd.DataFrame()
dff = pd.DataFrame()
for ijk in filesList:
    frame = pd.read_csv(ijk, delim_whitespace=True, skiprows=25, nrows=1,
                        usecols=[2], squeeze=True, header=None)
    df = df.append(frame)
    print(df)
    results = open('Mode3.txt', 'w+')
    df.to_string(results)
    results.close()
	
